{
  "name": "Beats Detector",
  "id": "sRFyDfKeAh5oEmgyp",
  "sources": {
    "main": "/*---------------------------------------------------/< Credits >/----------------------------------------------------\\\\\n\nMuch appreciation to Jeff Vyduna for his very extensive Music Sequencer posted here:\nhttps://forum.electromage.com/t/music-sequencer-choreography/1549\n\nMuch appreciation to MyMathematicalMind, for extracting the BPM detector from Jeff's framework\nhttps://forum.electromage.com/t/syncing-beat-detection-algorithm-to-multiple-pixelblazes/3233\n-MyMathematicalMind, 2023.\n\nDillon Simeone\n\nUseful variables to use: estimatedBeatsPerMinute, and export var BPMspeedFactor = 1. Use both to control the animation speed of stuff to make them BPM-reactive!\n//---------------------------------------------------/< Credits >/----------------------------------------------------*/\n\n//-----------------------------------------------/< Global Variables >/-----------------------------------------------\\\\\n\n// Values that come from the Sensor Board\nexport var light = -1 // If this remains at the impossible value of -1, a sensor board is not connected.\nfunction SB() { return light != -1 }  //Function to check if sensor board is connected: if(SB())==true if detected\nexport var frequencyData = array(32)  //Get all the frequencies samples in an array\n\n//Timing variables\nexport var BPM = 120\nexport var globalDelta = 0\nexport var overRideBPM = 0\n\n\n//Debounce variables\nvar minBeatRetrigger = .2 /* How much of a currently defined quarter note beat must pass before a detected instrument \n                              will retrigger? E.g. use .2 to allow .25 retrigger (e.g. to catch sixteenth note drums)*/\nvar debounceTimer = beatsToMs(minBeatRetrigger)\n\n//Bass variables\nvar bass, maxBass, bassOn    /* Bass and beats. (bassOn==true) is what triggers the debounce calculation and ultimately \n                                whether or not beatDetected() is called*/\nvar bassSlowEMA = .001, bassFastEMA = .001 // Exponential moving averages to compare to each other\nvar bassThreshold = .02      // Raise this if very soft music with no beats is still triggering the beat detector\nvar maxBass = bassThreshold  // Maximum bass detected recently (while any bass above threshold was present)\nvar bassVelocitiesSize = 2*pow(beatSensitivity, 2) + 11*beatSensitivity + 2 /* bassVelocitiesSize=5 seems right for \nmost. Up to 15 for infrequent bass beats (slower reaction, longer decay), down to 2 for very fast triggering on doubled \nkicks like in drum n bass */\nvar bassVelocities = array(bassVelocitiesSize) /* Circular buffer to store the last 5 first derivatives of the \n                                                `fast exponential avg/MaxSample`, used to calculate a running average */\nvar lastBassFastEMA = .5, bassVelocitiesAvg = .5\nvar bassVelocitiesPointer = 0 // Pointer for circular buffer\n\n//Tempo inference variables\n// Store the last 8 intervals between beats. Longest = 50BPM on beat 1 (4800 ms = 60 / 50BPM * 1000 * 4)\nvar beatIntervalSamples = 8, beatIntervalPtr = 0, beatIntervalTimer = 0\nexport var beatIntervals = array(beatIntervalSamples)\nexport var elapsedTime = 0, currentTime = 0, prevTime = 0\nexport var averageBeatsPerMs\nexport var estimatedBeatsPerMinute\n\n//UI controlled variables\nexport var beatSensitivity = 0.5\n\n//-----------------------------------------------\\< Global Variables >\\-----------------------------------------------\\\\\n\n//---------------------------------------------/< UI Control Functions >/---------------------------------------------\\\\\n\nexport function sliderBeatSensitivity(_v) { beatSensitivity = _v }\nexport function showNumberBeatSensitivity() { return beatSensitivity }\n\nexport function sliderBpmSpeedFactor(_v) { BPMspeedFactor = _v}\nexport function showNumberbpmSpeedFactor(){return BPMspeedFactor}\n\n//---------------------------------------------/< UI Control Functions >/---------------------------------------------\\\\\n\n//-------------------------------------------/< Beat Detection Functions >/-------------------------------------------\\\\\n\nfunction processSound(delt) {\n  processInstruments(delt)\n  inferTempo(delt)\n}\n\n// Debounce detector\nfunction debounce(trigger, fn, duration, elapsed) {\n  if (trigger && debounceTimer <= 0) { \n    fn()\n    debounceTimer = duration\n  } else { \n    debounceTimer = max(-3e4, debounceTimer - elapsed)\n  }\n}\n\nfunction processInstruments(delt) {\n  // Assume Sensor Board updates at 40Hz (25ms); Max BPM 180 = 333ms or 13 samples; Typical BPM 500ms, 20 samples\n  // Kickdrum fundamental 40-80Hz. https://www.bhencke.com/pixelblaze-sensor-expansion\n  bass = frequencyData[1] + frequencyData[2] + frequencyData[3]\n  maxBass = max(maxBass, bass)\n  if (maxBass > 10 * bassSlowEMA && maxBass > bassThreshold) maxBass *= .99 // AGC - Auto gain control\n  \n  bassSlowEMA = (bassSlowEMA * 999 + bass) / 1000\n  bassFastEMA = (bassFastEMA * 9 + bass) / 10\n}\n\nfunction inferTempo(delt) {\n  bassVelocities[bassVelocitiesPointer] = (bassFastEMA - lastBassFastEMA) / maxBass /* Normalized first derivative of \n                                                                                        fast moving expo avg */\n  bassVelocitiesAvg += bassVelocities[bassVelocitiesPointer] / bassVelocitiesSize\n  bassVelocitiesPointer = (bassVelocitiesPointer + 1) % bassVelocitiesSize\n  bassVelocitiesAvg -= bassVelocities[bassVelocitiesPointer] / bassVelocitiesSize\n  bassOn = bassVelocitiesAvg > .51 // `bassOn` is true when bass is rising\n  \n  debounce(bassOn, beatDetectedWrapper, beatsToMs(minBeatRetrigger), delt)\n  beatIntervalTimer += delt\n  // Longest = 50BPM on beat 1 (4800 ms = 60 / 50BPM * 1000 * 4)\n  if (beatIntervalTimer > 5000) beatIntervalTimer = 5000 // No-beat ms threshold to reset beat detection \n  lastBassFastEMA = bassFastEMA\n  \n  \n}\n\nfunction beatDetectedWrapper() {\n  if (beatIntervalTimer >= 5000) { // Clear beat intervals, it's been too long since a beat\n    beatIntervals.mutate(() => 0)\n    beatIntervalTimer = beatIntervalPtr = 0\n  }\n  beatIntervals[beatIntervalPtr] = beatIntervalTimer\n  beatIntervalTimer = 0\n  beatIntervalPtr = (beatIntervalPtr + 1) % beatIntervalSamples\n  beatDetected() // Calls a user-customized function that happens whenever a beat is detected\n}\n\n// Do this whenever a beat is detected\nfunction beatDetected() {\n  averageBeatsPerMs = 0\n  \n  for(var i = 0; i < beatIntervals.length; i++)\n      averageBeatsPerMs += beatIntervals[i] //Adds up all of the beat intervals\n  \n  averageBeatsPerMs = averageBeatsPerMs/(beatIntervals.length) //Average the intervals out\n  var averageBeatsPerMsAdjusted = averageBeatsPerMs/100 //Makes this to work within pixelblaze's limits\n     \n  estimatedBeatsPerMinute = 600/(averageBeatsPerMsAdjusted) // Normally this'd be 60000/averageBeatsPerMs and done, bpm got. Pixelblaze limits to 32k~ in either directions. \n}\n\n//-------------------------------------------/< Beat Detection Functions >/-------------------------------------------\\\\\n\n//------------------------------------------------/< Misc Functions >/------------------------------------------------\\\\\n\nfunction updateDeltaTimer() {\n  currentTime = 1000*time(1/65.536)\n  if (currentTime >= prevTime) {\n    elapsedTime += currentTime-prevTime\n  } else {\n    elapsedTime += 1 - (prevTime - currentTime)\n  }\n  prevTime = currentTime\n  globalDelta = elapsedTime\n  elapsedTime = 0\n}\n\nfunction beatsToMs(_beats) { return (1000 / BPM * 60 * _beats) }\n\n\n\n//------------------------------------------------/< Misc Functions >/------------------------------------------------\\\\\n\n//----------------------------------------------/< Runtime Functions >/-----------------------------------------------\\\\\n\nexport function beforeRender(globalDelta) {\n  updateDeltaTimer()\n  if(SB()) processSound(globalDelta)  //Update all sound related variables to be used by the patterns\n}"
  },
  "preview": "/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCACWAGQDAREAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD8qqACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAP/Z"
}