{
  "name": "sound - rays Frequency-BPM Reactive 1",
  "id": "npb7eQGfzNcXbQ37g",
  "sources": {
    "main": "/*---------------------------------------------------/< Credits >/----------------------------------------------------\\\\\n\nMuch appreciation to Jeff Vyduna for his very extensive Music Sequencer posted here:\nhttps://forum.electromage.com/t/music-sequencer-choreography/1549\n\nMuch appreciation to MyMathematicalMind, for extracting the BPM detector from Jeff's framework\n-MyMathematicalMind, 2023.\n\n-Dillon Simeone, 2024\n\n//---------------------------------------------------/< Credits >/----------------------------------------------------*/\n\n//-----------------------------------------------/< Global Variables >/-----------------------------------------------\\\\\n\n\n// Values that come from the Sensor Board\nexport var light = -1 // If this remains at the impossible value of -1, a sensor board is not connected.\nfunction SB() { return light != -1 }  //Function to check if sensor board is connected: if(SB())==true if detected\nexport var frequencyData = array(32)  //Get all the frequencies samples in an array\n\n//Timing variables\nexport var BPM = 120\nexport var globalDelta = 0\n\n//Debounce variables\nvar minBeatRetrigger = .2 /* How much of a currently defined quarter note beat must pass before a detected instrument \n                              will retrigger? E.g. use .2 to allow .25 retrigger (e.g. to catch sixteenth note drums)*/\nvar debounceTimer = beatsToMs(minBeatRetrigger)\n\n//Bass variables\nvar bass, maxBass, bassOn    /* Bass and beats. (bassOn==true) is what triggers the debounce calculation and ultimately \n                                whether or not beatDetected() is called*/\nvar bassSlowEMA = .001, bassFastEMA = .001 // Exponential moving averages to compare to each other\nvar bassThreshold = .02      // Raise this if very soft music with no beats is still triggering the beat detector\nvar maxBass = bassThreshold  // Maximum bass detected recently (while any bass above threshold was present)\nvar bassVelocitiesSize = 2*pow(beatSensitivity, 2) + 11*beatSensitivity + 2 /* bassVelocitiesSize=5 seems right for \nmost. Up to 15 for infrequent bass beats (slower reaction, longer decay), down to 2 for very fast triggering on doubled \nkicks like in drum n bass */\nvar bassVelocities = array(bassVelocitiesSize) /* Circular buffer to store the last 5 first derivatives of the \n                                                `fast exponential avg/MaxSample`, used to calculate a running average */\nvar lastBassFastEMA = .5, bassVelocitiesAvg = .5\nvar bassVelocitiesPointer = 0 // Pointer for circular buffer\n\n//Tempo inference variables\n// Store the last 8 intervals between beats. Longest = 50BPM on beat 1 (4800 ms = 60 / 50BPM * 1000 * 4)\nvar beatIntervalSamples = 8, beatIntervalPtr = 0, beatIntervalTimer = 0\nexport var beatIntervals = array(beatIntervalSamples)\nexport var elapsedTime = 0, currentTime = 0, prevTime = 0\nexport var averageBeatsPerMs\nexport var estimatedBeatsPerMinute\n\n//UI controlled variables\nexport var beatSensitivity = 0.5\nexport var BPMspeedFactor = 1\n\n//---------------------------------------------/< UI Control Functions >/---------------------------------------------\\\\\n\nexport function sliderBeatSensitivity(_v) { beatSensitivity = _v }\nexport function showNumberBeatSensitivity() { return beatSensitivity }\n\nexport function sliderBpmSpeedFactor(_v) { BPMspeedFactor = _v}\nexport function showNumberbpmSpeedFactor(){return BPMspeedFactor}\n\n//---------------------------------------------/< UI Control Functions >/---------------------------------------------\\\\\n\n//-------------------------------------------/< Beat Detection Functions >/-------------------------------------------\\\\\n\nfunction processSound(delt) {\n  processInstruments(delt)\n  inferTempo(delt)\n}\n\n// Debounce detector\nfunction debounce(trigger, fn, duration, elapsed) {\n  if (trigger && debounceTimer <= 0) { \n    fn()\n    debounceTimer = duration\n  } else { \n    debounceTimer = max(-3e4, debounceTimer - elapsed)\n  }\n}\n\nfunction processInstruments(delt) {\n  // Assume Sensor Board updates at 40Hz (25ms); Max BPM 180 = 333ms or 13 samples; Typical BPM 500ms, 20 samples\n  // Kickdrum fundamental 40-80Hz. https://www.bhencke.com/pixelblaze-sensor-expansion\n  bass = frequencyData[1] + frequencyData[2] + frequencyData[3]\n  maxBass = max(maxBass, bass)\n  if (maxBass > 10 * bassSlowEMA && maxBass > bassThreshold) maxBass *= .99 // AGC - Auto gain control\n  \n  bassSlowEMA = (bassSlowEMA * 999 + bass) / 1000\n  bassFastEMA = (bassFastEMA * 9 + bass) / 10\n}\n\nfunction inferTempo(delt) {\n  bassVelocities[bassVelocitiesPointer] = (bassFastEMA - lastBassFastEMA) / maxBass /* Normalized first derivative of \n                                                                                        fast moving expo avg */\n  bassVelocitiesAvg += bassVelocities[bassVelocitiesPointer] / bassVelocitiesSize\n  bassVelocitiesPointer = (bassVelocitiesPointer + 1) % bassVelocitiesSize\n  bassVelocitiesAvg -= bassVelocities[bassVelocitiesPointer] / bassVelocitiesSize\n  bassOn = bassVelocitiesAvg > .51 // `bassOn` is true when bass is rising\n  \n  debounce(bassOn, beatDetectedWrapper, beatsToMs(minBeatRetrigger), delt)\n  beatIntervalTimer += delt\n  // Longest = 50BPM on beat 1 (4800 ms = 60 / 50BPM * 1000 * 4)\n  if (beatIntervalTimer > 5000) beatIntervalTimer = 5000 // No-beat ms threshold to reset beat detection \n  lastBassFastEMA = bassFastEMA\n  \n  \n}\n\nfunction beatDetectedWrapper() {\n  if (beatIntervalTimer >= 5000) { // Clear beat intervals, it's been too long since a beat\n    beatIntervals.mutate(() => 0)\n    beatIntervalTimer = beatIntervalPtr = 0\n  }\n  beatIntervals[beatIntervalPtr] = beatIntervalTimer\n  beatIntervalTimer = 0\n  beatIntervalPtr = (beatIntervalPtr + 1) % beatIntervalSamples\n  beatDetected() // Calls a user-customized function that happens whenever a beat is detected\n}\n\n// Do this whenever a beat is detected\nfunction beatDetected() {\n  \n  averageBeatsPerMs = 0\n  \n  \n  for(var i = 0; i < beatIntervals.length; i++)\n      averageBeatsPerMs += beatIntervals[i] //Adds up all of the beat intervals\n  \n  averageBeatsPerMs = averageBeatsPerMs/(beatIntervals.length) //Average the intervals out\n  var averageBeatsPerMsAdjusted = averageBeatsPerMs/100 //Makes this to work within pixelblaze's limits\n     \n  estimatedBeatsPerMinute = 600/(averageBeatsPerMsAdjusted) // Normally this'd be 60000/averageBeatsPerMs and done, bpm got. Pixelblaze limits to 32k~ in either directions. \n  speed = (estimatedBeatsPerMinute/10000) * BPMspeedFactor\n  /*\n    \"Pixelblaze's language is based on JavaScript (ES6) syntax, but with a subset of the language features available. \n    All numbers in Pixelblaze are 16.16 fixed-point numbers. This can handle values between -32,768 to +32,768 with \n    fractional accuracy down to 1/65,536ths.\"\n    \n    Pixelblaze limits:\n    60000/200 = -27.67\n    60000/20 = -276.8\n    60000/2 = -2768\n    \n    6000/2 = 3000\n    6000/20 = 300\n    6000/200 = 30\n    6000/2000 = 3\n    \n    6000/20000 = 0.29....\n  */\n}\n\n//-------------------------------------------/< Beat Detection Functions >/-------------------------------------------\\\\\n\n//------------------------------------------------/< Misc Functions >/------------------------------------------------\\\\\n\nfunction updateDeltaTimer() {\n  currentTime = 1000*time(1/65.536)\n  if (currentTime >= prevTime) {\n    elapsedTime += currentTime-prevTime\n  } else {\n    elapsedTime += 1 - (prevTime - currentTime)\n  }\n  prevTime = currentTime\n  globalDelta = elapsedTime\n  elapsedTime = 0\n}\n\nfunction beatsToMs(_beats) { return (1000 / BPM * 60 * _beats) }\n\n\n/*\n  Sound - rays\n\n  This pattern is designed to use the sensor expansion board, but falls back to\n  simulated sound data if the sensor board isn't detected.\n\n  The beginning of the strip will originate pixels with color based on the most\n  prevalent frequency in the sound, and brightness based on the magnitude. Those\n  rays of color will then travel down the strip.\n\n  Please check out the \"sound - blink fade\" pattern for more verbose comments\n  explaining the PI controller used below for automatic gain control. \n*/\n\n\n// Speed that the rays travel down the strip\n\nspeed = 0.05\n\n// These vars are set by the external sensor board, if one is connected. We\n// don't actually use light readings in this pattern, so if the `light` value\n// remains -1, no sensor board is connected.\nexport var light = -1 \nexport var maxFrequencyMagnitude\nexport var maxFrequency\nexport var sensitivity\n\nhues = array(pixelCount)\nvals = array(pixelCount)\n\n// A position pointer, in pixels, that turns hues[] and vals[] into a circular\n// buffer\npos = 0\n// Stores the last brightness value to feed back into the PI gain controller \nlastVal = 0\n\nexport var pic = makePIController(.05, .35, 200, 0, 400)\n\n// Make a new PI Controller\nfunction makePIController(kp, ki, start, min, max) {\n  var pic = array(5)\n  pic[0] = kp\n  pic[1] = ki\n  pic[2] = start // This is the accumulated error\n  pic[3] = min\n  pic[4] = max\n  return pic\n}\n\nfunction calcPIController(pic, err) {\n  pic[2] = clamp(pic[2] + err, pic[3], pic[4])\n  return max(pic[0] * err + pic[1] * pic[2], .3)\n}\n\nexport function beforeRender(globalDelta) {\n  updateDeltaTimer()\n  if(SB()) processSound(globalDelta)  //Update all sound related variables to be used by the patternsw\n  \n  // Here the PI controller is aiming for a sensitivity based on chasing recent\n  // maxFrequencyMagnitudes to be 0.5\n  sensitivity = calcPIController(pic, 0.5 - lastVal)\n  \n  // To make the rays travel along the strip, sweep a position offset pointer\n  // down the arrays of values and hues\n  pos = (pos + globalDelta * speed) % pixelCount\n  \n  if (light == -1) simulateSound()  // No sensor board attached\n  \n  // The brightness value will be determined by the magnitude of the most\n  // intense frequency. This is also our feedback to the PI controller.\n  lastVal = vals[pos] = pow(maxFrequencyMagnitude * sensitivity, 2)\n  \n  /*\n    The base color will be modified by time and strip position in render(), but\n    its hue begins based on the most intense frequency detected. If you played a\n    swept tone between 20 Hz and 5 KHz, it'd trace a rainbow. \n  */\n  hues[pos] = maxFrequency / 5000\n\n  // Used to subtly advance the hue over time\n  // --- t1 = time(6.5 / 65.536)\n}\n\nexport function render(index) {\n  // Reverse indices so that pixels flow to the right\n  index = pixelCount - index\n  // Shift the index circularly based on the position offset\n  i = (index + pos) % pixelCount\n  \n  h = hues[i]\n  /*\n    This rotates color by adding a component based on time and position.  \n    Comment this out to more clearly see the detected maximum frequencies.\n    Adding `index / pixelCount / 4` adds a quarter of the hue wheel across the\n    strip's entire length. Notice that since index is reversed, *adding* t1 back\n    in has the effect of *slowing* the hue progression.\n  */\n  // --- h += index / pixelCount / 4 + t1\n\n  v = vals[i]\n  v = v * v  // Gamma correction\n  \n\n  hsv(h, 1, v)\n}\n\n/* \n  Simulate the sensor board variables used in this pattern, if no senor board is\n  detected. The values and waveforms were chosen to approximate the look when\n  sound is sensed. \n*/\nfunction simulateSound() { \n  t1 = time(10 / 65.536) \n  maxFrequency = 2000 * (1 + wave(t1)) * (0.7 + random(0.3)) \n  maxFrequencyMagnitude = log(1.05 + wave(17 * t1) * wave( 19 * t1) * wave(23 * t1)) \n  maxFrequencyMagnitude *= 0.7 + random(0.3)\n}\n"
  },
  "preview": "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"
}